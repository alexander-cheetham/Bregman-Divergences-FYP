
<!DOCTYPE html>
<html lang="en">
  <head>
    <script type="text/javascript" src="bregdivs.js"></script>
    <script type="text/javascript" charset="UTF-8"
 src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
    <!-- To automatically render math in text elements -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>
        <script src="all.min.js"></script>
    <script src="statistics.min.js" type="text/javascript"></script>
    <link rel="icon" type="image/png" href="alex-assets/mlu_robot.png" />
    <link rel="stylesheet" href="alex-assets/styles/normalize.css" />
    <link rel="stylesheet" href="alex-assets/styles/font.css" />
    <link rel="stylesheet" href="alex-assets/styles/katex.css" />
    <link rel="stylesheet" href="alex-assets/styles/global.css" />
    <link rel="stylesheet" href="alex-assets/bundle.css" />
    <link rel="stylesheet" href='success.css'>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.0/math.js"></script>
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.7/dist/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script> -->

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script>

    <!--<script defer src="alex-assets/bundle.js"></script> this does loads -->

    <!-- meta tags -->
    <title>Bregman Divergences</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="description"
      content="A visual, interactive explanation of Bregman Divergences."
    />
    <meta name="author" content="Alexander Cheetham" />
    <!-- <meta
      name="news_keywords"
      content="linear regression classification threshold binary visual machine learning mean squared error r-squared gradient descent closed form least squares interpretability multivariate"
    />
    -->
    <meta property="og:title" content="Bregman Divergences" />

    <meta property="og:type" content="article" />
    <meta property="og:locale" content="en_US" />

    <meta property="og:image:type" content="image/jpg" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="600" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>

<body>
  <section id="intro" style=' width: 60%; margin: auto;text-align: center' >
      <h1 id="intro-hed">Bregman Divergences</h1>
      <h2 id="intro-sub" style='font-family: "Amazon Ember Mono"'>A Visual Introduction to Bregman Divergences</h2>
      <h3 id="intro__date"  style='font-family: "Amazon Ember Mono"'><a >Alexander Cheetham</a>, September 2022</h3>
</section>

<br>
<section class='panel'>
<h2 class="body-header">Introduction</h2>
<p class="body-text">
Bregman divergences are a widely used mathematical concept in machine learning that are often discussed
 in theoretical papers, but can be challenging to understand for those encountering them for the first time.
  These divergences are significant because of their usefulness in many areas of machine learning such as
  clustering and matrix approximations \(\textbf{cite}\).
   However, the formalism-heavy Wikipedia page on Bregman divergences may not be the most accessible
    resource for beginners. In this regard, this page aims to provide a comprehensive and easy-to-understand
     introduction to Bregman divergences. It will cover their definition, derivation, and useful properties,
      while also discussing the role they play in machine learning. Additionally, interactive graphs will be
       provided to enhance understanding.
</p>
<div id='bibl'>
</div>
</section>
<section class='panel'>
<h2 class="body-header">History</h2>
<p class="body-text">
The Bregman divergence first appeared in a paper on solutions to convex
programming problems.
<br>
<img src="./alex-assets/images/paper-title.png" alt="Bregman Paper">
<br>
Appearing first in the section below.
<br>
<br>
<img src="./alex-assets/images/Definition.png" alt="Bregman Paper">
<br>
The definition of a Bregman divergence (retrospectively named such) was defined
in equation (1.4) as a result of trying a function that satisfied the
conditions below.
<br>
<br>
<img src="./alex-assets/images/Conditions1.png" alt="Bregman Paper">
<img src="./alex-assets/images/Conditions2.png" alt="Bregman Paper">
<br>
We will go deeper into some of these properties later in the article.
</p>
</section>
<section class='panel'>
<h2 class="body-header">Motivation and Derivation</h2>
<p class='body-text'>
The motivation for studying Bregman divergences comes from the idea of trying to
generalise the definition of squared Euclidean distance to a larger class of
distances that share the same properties. Alongside this, as we will see later
Bregman divergences have strong ties to applications in probability, machine
learning and clustering. \(\textcolor{red}{CITE\, mirrodescient motivation}\)
<br>
<br>
With this motivation in mind we will first generalise the
squared Euclidean distance(SED) between two points to a Bregman Divergence. Given two
points \( x,y \in \, \mathbb{R}^n \) the SED is: \(\textcolor{red}{CITE\, webarchive}\)
$$d^2(x,y):=\sum_{i=1}^{n} (x_i - y_i)^2 $$
We can rewrite the definition of the
SED in terms of the inner product (\( \langle x,y \rangle = \sum_{i=1}^{d} x_iy_i  \) ).
$$d^2(x,y):=\sum_{i=1}^{n} (x_i - y_i)^2 = \langle x-y,x-y \rangle $$
Then after some manipulation we get.
$$d^2(x,y) =  \langle x-y,x-y \rangle = \mid\mid x \mid\mid^2 -
 \mid\mid y \mid\mid^2 - \langle 2y,x-y \rangle $$

 <button class="btn btn-outline-primary" type="button" data-toggle="collapse" data-target="#proof1" aria-expanded="false" aria-controls="collapseExample">
    Explanation
  </button>
  </p>
  <div class="collapse" id="proof1">
  <div class="card card-body body-text">
    <p class='body-text'>
      $$\langle x-y,x-y \rangle=||x||^2 + ||y||^2 + ||2yx||$$
      $$||x||^2 + ||y||^2 + ||2yx|| = ||x||^2 - ||y||^2 + ||2y^2||+ ||2yx||$$
      $$||x||^2 - ||y||^2 + ||2y^2||+ ||2yx||=||x||^2- ||y||^2 - (||2y^2||- ||2yx||)$$
      $$\langle 2y,x-y \rangle = |2y^2||- ||2yx||$$
      $$||x||^2- ||y||^2 - (||2y^2||- ||2yx||)=||x||^2- ||y||^2 - \langle 2y,x-y \rangle$$
  </p>
  </div>
</div>
<p class="body-text">
And after noticing that \( \frac{d}{dy}||y^2|| = 2y \) we can now rewrite the
equation in terms of the derivative of a function namely \( f(x)=x^2\)
$$d^2(x,y) = f(x) - (f(y) + \langle\nabla f(y),x-y\rangle) $$
<br>
After comparing to bregman's paper below we see that the definitions do indeed
match and therefore SED is a bregman divergence!
<br>
<img src="./alex-assets/images/Definition.png" alt="Bregman Paper">
<br>
This also lends itself to a particularly nice geometrical interpretation if we
realise that \( f(y) + \langle\nabla f(y),x-y\rangle \) is the tangent line of f
at y.
<br>
<br>
<div id="box" class="jxgbox" style="width:45%; height:70vh; margin: auto;"></div>
<script type="text/javascript">


 var board = JXG.JSXGraph.initBoard('box', {boundingbox: [-10, 10, 12, -4]});
 board.options.text.cssStyle = 'font-family: "Amazon Ember Mono"'
 var xaxis = board.create('axis', [[0.0, 0.0], [0.0, 1]]);
 var yaxis = board.create('axis', [[0.0, 0.0], [1.0, 0]]);

 theSlider = board.create('slider',[[-9,8],[-4,8],[0,0.1,1]],
  {snapWidth:0.05});
  board.create('text',[-9,8.5,
   function(){

     return 'f(x) = '+Math.round(theSlider.Value()* 100) / 100+'x^2';
   }], {fontSize: 15,})
 theFct = board.create('functiongraph',
   [function(x){return theSlider.Value()*x*x;}],{strokeColor:'#000',strokeWidth:2, highlight: false});
 yGlider = board.create('glider',[theFct],{name:'y', highlight: false,strokeColor:'#013081',fillColor:'#013081'});
 yGlider.moveTo([1.68,0.56])
 board.create('tangent', [yGlider], {strokeColor:'#FF9900',strokeWidth:2, highlight: false});
 xGlider = board.create('glider',[theFct],{name:'x', highlight: false,strokeColor:'#013081',fillColor:'#013081'});
 xGlider.moveTo([5.83,6.79])



 c = yGlider.Y()-2*theSlider.Value()*yGlider.X()**2
 yout = 2*theSlider.Value()*yGlider.X()*xGlider.X()+c
 jl = board.create('segment',[xGlider,[xGlider.X(),yout]],{strokeColor:'#013081',strokeWidth:3, highlight: false});

 board.create('text',[1,8,
  function(){
    var distance = Math.round((xGlider.Y()-yout)**2* 100) / 100
    return '||x-y||^2 = '+distance;
  }], {fontSize: 15,},position='u')
 xGlider.on('up', function(e){
    c = yGlider.Y()-2*theSlider.Value()*yGlider.X()**2
    yout = 2*theSlider.Value()*yGlider.X()*xGlider.X()+c
    board.removeObject(jl);
    board.update()
    jl = board.create('segment',[xGlider,[xGlider.X(),yout]],{strokeColor:'#013081',strokeWidth:3, highlight: false});
});
yGlider.on('up', function(f){
  board.removeObject(jl);
  c = yGlider.Y()-2*theSlider.Value()*yGlider.X()**2
  yout = 2*theSlider.Value()*yGlider.X()*xGlider.X()+c
  jl= board.create('segment',[xGlider,[xGlider.X(),yout]],{strokeColor:'#013081',strokeWidth:3, highlight: false});
  board.update()
});

theSlider.on('down', function(h){
   board.removeObject(jl);
});



</script>
<br>
<br>
</p>
<p class='body-text'>
  Handily, if we state explicitly that our distance measure must be non-negative
  we can redefine our distance measure as
  $$d^2(x,y) := f(x) - (f(y) + \langle\nabla f(y),x-y\rangle) \geq 0$$
  This tells us that function must lie above the tangent line for all \(x,y\)
  and gives the following inequality.
  $$f(x) \geq f(y) + \langle\nabla f(y),x-y\rangle $$
  Which is precisely the definition, assuming the function is appropriately
  differentiable, the definition of a convex function.
  <br>
  <br>
<span class="bold">Exploration of the formal definition</span>
The complete definition of a bregman divergence is presented below
<br>
  <span style='font-size: 30px; color: var(--smile);'>·</span>let F : \( \Omega
  \rightarrow \mathbb{R} \) is <color style='color: var(--smile);weight: Bold;'>continuously differentiable</color> &
 <color style='color: var(--smile);weight: Bold;'>strictly convex</color> function on the <color style='color: var(--smile);weight: Bold;'>convex set</color> \(\Omega\) with two n-dimensional
 points \(x,y \in \Omega\)<br>

 <span style='font-size: 30px; color: var(--smile);'>·</span>
  \( F(x) - (F(y) + \langle\nabla F(y),x-y\rangle) \)<br>
  <span style='font-size: 30px; color: var(--smile);'>·</span>The difference
   between the function evaluated at x and the first order Taylor approximation
   of F around y evaluated at x<br>

<br>
</p>
<p >
<nav style='width:80%;margin:auto;'>
  <div class="nav nav-tabs" id="nav-tab" role="tablist">
    <a  style='color: #000'class="nav-item nav-link body-text" id="nav-convex-tab" data-toggle="tab"
    href="#nav-contact" role="tab" aria-controls="nav-contact" aria-selected="false">Convex Set</a>
    <a style='color: #000' class="nav-item nav-link active body-text" id="nav-contdiff-tab" data-toggle="tab"
    href="#nav-home" role="tab" aria-controls="nav-home" aria-selected="false">
  Continuously Differentiable</a>
    <a style='color: #000' class="nav-item nav-link body-text" id="nav-strcon-tab" data-toggle="tab"
    href="#nav-profile" role="tab" aria-controls="nav-profile" aria-selected="false">Strictly Convex</a>

  </div>
</nav>
<div class="tab-content card body-text" id="nav-tabContent" style='width:100%;margin:auto;'>
  <div class="tab-pane fade show active" id="nav-home" role="tabpanel" aria-labelledby="nav-contdiff-tab">
    The derivative must also be continuous.</div>
  <div class="tab-pane fade" id="nav-profile" role="tabpanel" aria-labelledby="nav-strcon-tab">
    A function such that any straight
    line between any pair of points
    on the curve is above the curve excluding the intersection of the line and the
    curve.
  </div>

  <div class="tab-pane fade" id="nav-contact" role="tabpanel" aria-labelledby="nav-convex-tab">
    The definition of strict convexity is a function such that any straight
    line between any pair of points
    on the curve is above the curve including the intersection of the line and the
    curve.
    </div>
</div>
</p>


<br>
</section>
<section class='panel'>
<h2 class="body-header">General Bregman Divergence Plots: </h2>
<br>

<div style='width:80%;margin:auto;text-align: center'>
  <p>
    Below is a widget that will test the convexity of a function and if the function
    is of form \(f: \mathbb{R} \rightarrow \mathbb{R}\) the accompanying bregman plots will be displayed.
  </p>
<input class="btn btn-primary" onclick="reset_panels()" type="reset" value="↺ Reset">
</div>
<br>
<br>
<div id='inputeq' class='body-text' style='width:45%;margin:auto;text-align: center'>
    <p> Please enter your continuous function of class \(f:\mathbb{R}^n \rightarrow \mathbb{R}\)</p>
    <label for="lossfunc">Generator function</label>
    <input type="text" id="lossfunc">
    <p>The function must have a second derivative that exists for computational tractability</p>
    <button class="btn btn-primary" id="generate" onclick="generate()">Generate</button>
    <br>
</div>
<div id='panel2' class = 'body-text' style='margin:auto;text-align: center;
display:none;'>
<div  id="eqhead">
  Inputted Equation:
</div>
<span id="lossfuncoutput"></span>
<div id='bounds_boxes'></div>
<div style='text-align:center' id='buttoncontainer'></div>
<button class="btn btn-primary" id="generate2" onclick="generate2()">Submit</button>
</div>
<div style='width:45%;margin:auto;text-align: center;display:none;'  id=panel3>
  <div style='text-align:center;margin:auto;' id='convexity_test'></div>

  </div>
  <div style='width:90%;margin:auto;text-align: center;display:none;'  id=panel4>
    <div class="container">
      <div class="row">
        <div class="col-sm">
          Generator Function:
          <div id='generatorlatex'></div>
          <div id="generatorbox" class="jxgbox" style="width:100%; height:50vh; margin: auto;"></div>
        </div>
        <div class="col-sm">
          Bregman Divergence:
          <div id='divergencelatex'></div>
          <div id="divergencebox" class="jxgbox" style="width:100%; height:50vh; margin: auto;"></div>
        </div>
      </div>
    </div>

    </div>


<script>
    var inputeq = document.getElementById('inputeq');
    var panel2 = document.getElementById('panel2');
    var output = document.getElementById('lossfuncoutput');
    var input = document.getElementById('lossfunc');
    var container = document.getElementById('buttoncontainer');
    var var_error = document.getElementById('variable_error')
    var bounds = document.getElementById('bounds_boxes')
    var convexity_div = document.getElementById('convexity_test')

    function linspace(start, stop,dt, endpoint = true) {
        const step = dt;
        const num = (1/dt)*((stop -start)  )+1
        return Array.from({length: num}, (_, i) => start + step * i);
    }

    function generate() {
        try {
            inputted_equation = nerdamer(input.value)
            vars = nerdamer(input.value).variables()
            vars = vars.filter(onlyUnique);
            katex.render(nerdamer(input.value).toTeX(),lossfuncoutput);
            inputeq.style.display='none';
            panel2.style.display='block'
            variables = []
            vars.forEach(function(variable){
               outer = document.createElement('div')
               outer.setAttribute('class','input-group')
               innerdiv = document.createElement('div')
               innerdiv.setAttribute('class','input-group-prepend')
               text = document.createElement('span')
               text.innerHTML = 'Stepsize & Lower/Upper bounds for: '+variable+' ';
               text.setAttribute('class','input-group-text')
               innerdiv.appendChild(text)
               inp1 = document.createElement('input')
               inp1.setAttribute('type','number')
               inp1.setAttribute('class','form-control')
               inp1.setAttribute('id',variable+'lbound')
               inp2 = document.createElement('input')
               inp2.setAttribute('type','number')
               inp2.setAttribute('class','form-control')
               inp2.setAttribute('id',variable+'ubound')
               inp3 = document.createElement('input')
               inp3.setAttribute('type','number')
               inp3.setAttribute('class','form-control')
               inp3.setAttribute('id','stepsize')
               outer.appendChild(innerdiv)
               outer.appendChild(inp1)
               outer.appendChild(inp2)
               outer.appendChild(inp3)
               bounds.appendChild(outer)
               variables.push(variable)
           });

        } catch (e) {
            alert(e.message);
        }
    }
    function generate2(){
      panel2.style.display = 'none';
      panel3 = document.getElementById('panel3');
      panel3.style.display = 'block';
      var inputs = panel2.querySelectorAll("input");
      bounds=[]
      bounds_copy=[]
      inputs.forEach(function(k){
        bounds.push(parseFloat(k.value))
        bounds_copy.push(parseFloat(k.value))
      })
      stepsizes = []
      var i = Math.floor(bounds.length / 3);

      while (i--) {
        stepsizes.push(bounds[(i + 1) * 3 - 1])
        bounds.splice((i + 1) * 3 - 1, 1);
      }
      if(isConvex(inputted_equation,bounds,variables)==true){
        writing = document.createElement('div')
        katex.render(nerdamer(input.value).toTeX(),writing);
        morewriting = document.createElement('p')
        morewriting.innerHTML = 'Congratulations your function: '
        lastwriting = document.createElement('p')
        lastwriting.innerHTML = 'Is strictly convex'
        convexity_div.appendChild(morewriting)
        convexity_div.appendChild(writing)
        convexity_div.appendChild(lastwriting)

        //console.log(nerdamer(input.value).variables())
        if(nerdamer(input.value).variables().length==1){
          button = document.createElement('button')
          button.classList.add("btn","btn-primary")
          button.setAttribute('id','generate3')
          original_variable = nerdamer(input.value).variables()[0]
          p_var = nerdamer(input.value).sub(original_variable,"p")
          q_var = nerdamer(input.value).sub(original_variable,"q")
          diff_q = nerdamer.diff(q_var,'q')
          //difference_p_q = p_var.subtract(q_var)
          innerprod = diff_q.multiply(nerdamer('p').subtract(nerdamer('q')));
          bregdiv = p_var.subtract(q_var.add(innerprod))
          plot_data = {
            generator: nerdamer(input.value).sub(original_variable,"x"),
            bregdiv: bregdiv,
            bounds: bounds_copy
          }
          button.onclick = plot_user_breg(plot_data)
          button.innerHTML = 'Plot.'
          convexity_div.appendChild(button)
        }

      } else{
        writing = document.createElement('div')
        katex.render(nerdamer(input.value).toTeX(),writing);
        morewriting = document.createElement('p')
        morewriting.innerHTML = 'Unfortunately your function: '
        lastwriting = document.createElement('p')
        lastwriting.innerHTML = 'Is not strictly convex'
        convexity_div.appendChild(morewriting)
        convexity_div.appendChild(writing)
        convexity_div.appendChild(lastwriting)
      }

    }



  function minima_over_range(f,range,div=null){
    linspace_var = linspace(range[0],range[1],range[2])
    if (div==null){
      minima = f(range[0])
      for (var i=0;i<linspace_var.length;i+=1){
        minima = Math.min(minima,f(linspace_var[i]))
      }
      return minima
    } else{
      minima = f(range[0],div)
      for (var i=0;i<linspace_var.length;i+=1){
        minima = Math.min(minima,f(linspace_var[i],div))
      }
      return minima
    }

  }

  function plot_user_breg(data){
    nerdamer.clearVars()
    panel3.style.display = 'none';
    generator_string = "\\bold{\\phi(x)}=".concat(data.generator.toTeX())
    katex.render(generator_string,document.getElementById('generatorlatex'))
    generator_f = data.generator.buildFunction()
    top_left= Math.max(generator_f(data.bounds[0]),generator_f(data.bounds[1]))
    bottom_right = minima_over_range(generator_f,data.bounds)
    bounds_diff = bounds[1]-bounds[0]
    y_diff = Math.abs(top_left - bottom_right)
    var generatorboard = JXG.JSXGraph.initBoard('generatorbox', {boundingbox:[bounds[0]-0.3*bounds_diff,top_left+0.3*y_diff+0.5,bounds[1]+0.3*bounds_diff,bottom_right-(0.3*y_diff+0.5)], axis:true, showNavigation:false});
    generatorboard.options.text.cssStyle = 'font-family: "Amazon Ember Mono"'
    generator = generatorboard.create('functiongraph', [function(x){ return generator_f(x); },-10, 10],{strokeColor:'#000',strokeWidth:2, highlight: false});
    //fix_generator = generatorboard.create('slider',[[bounds[0]+Math.abs(0.3*bounds[0]+5),top_left-0.3*top_left],[bounds[1]-Math.abs(0.3*bounds[1]+5),top_left-0.3*top_left],[0,0.7,1]],{snapWidth:0.05,label:{autoPosition: true, offset:[100, 100]}});
    //fix_generator = generatorboard.create('glider',[generator],{name:'x', highlight: false,strokeColor:'#013081',fillColor:'#013081'});
    fix_generator = generatorboard.create('slider',
    [[bounds[0],0.75*(top_left+0.3*y_diff+0.5)],
    [bounds[1],0.75*(top_left+0.3*y_diff+0.5)],[bounds[0],(bounds[0]+bounds[1])/2,bounds[1]]],
    {
      label: {fontSize: 18, strokeColor: 'black'},
              name: 'xyz',
               visible: true,
              suffixLabel: 'x = ',
    }
    );
    generator_fixed_point = generatorboard.create('glider', [fix_generator.Value(), generator_f(fix_generator.Value()),generator],{ highlight: false,name:'x',label:{autoPosition: true, offset:[-10, 10]}});
    generator_fixed_point.setAttribute({ fixed: true });
    generator_tangent = generatorboard.create('tangent', [generator_fixed_point], {strokeColor:'#FF9900',strokeWidth:2, highlight: false});
    generator_val = fix_generator.Value()
    fix_generator.on('up', function(i){
      generator_val = fix_generator.Value()
      generatorboard.removeObject(generator_fixed_point)
      generatorboard.removeObject(generator_tangent)
      generatorboard.removeObject(generator_breg_dist_seg)
      generator_fixed_point = generatorboard.create('glider', [fix_generator.Value(), generator_f(fix_generator.Value()),generator],{ highlight: false,name:'x',label:{autoPosition: true, offset:[-10, 10]}});
      generator_fixed_point.setAttribute({ fixed: true });
      generator_tangent = generatorboard.create('tangent', [generator_fixed_point], {strokeColor:'#FF9900',strokeWidth:2, highlight: false});
      generator_breg_dist_seg = generatorboard.create('segment',[generator_fixed_y,[generator_fixed_y.X(),generator_fixed_y.Y()-divergence_f(generator_fixed_y.X(),generator_val)]],{strokeColor:'#013081',strokeWidth:3, highlight: false,label:{autoPosition: true, offset:[10, 10]}});
      divergenceboard.removeObject(divergence);
      divergenceboard.removeObject(divergence_fixed_point);
      divergence_fixed_point = divergenceboard.create('point', [fix_generator.Value(), 0],{ highlight: false,name:'x',label:{autoPosition: true, offset:[-10, 10]}});
      divergence = divergenceboard.create('functiongraph', [function(x){ return divergence_f(generator_val,x); },-10, 10],{strokeColor:'#000',strokeWidth:2, highlight: false});
      free_glider = divergenceboard.create('glider',[fix_free.Value(),divergence_f(generator_val,fix_free.Value()),divergence],{name:'y', highlight: false,strokeColor:'#013081',fillColor:'#013081',label:{autoPosition: true, offset:[10, 10]}});
      free_eval = divergence_f(free_glider.X(),generator_val)
      breg_dist_seg = divergenceboard.create('segment',[free_glider,[free_glider.X(),0]],{strokeColor:'#013081',strokeWidth:3, highlight: false,label:{autoPosition: true, offset:[10, 10]}});
      breg_dist_seg.setLabel('D(x||y)= '+Math.round(free_eval*100)/100)

      free_glider.on('up', function(i){
        free_eval = divergence_f(free_glider.X(),generator_val)
        divergenceboard.removeObject(breg_dist_seg);
        breg_dist_seg = divergenceboard.create('segment',[free_glider,[free_glider.X(),0]],{strokeColor:'#013081',strokeWidth:3, highlight: false,label:{autoPosition: true, offset:[10, 10]}});
        breg_dist_seg.setLabel('D(x||y)= '+Math.round(free_eval*100)/100)
        divergenceboard.update()
      });
      divergenceboard.update()
    });
    generatorboard.fullUpdate()

    divergence_string = "d_{\\phi}(x,y)=".concat(nerdamer.simplify(data.bregdiv.sub('p','x').sub('q','y').toString()).toTeX())
    katex.render(divergence_string,document.getElementById('divergencelatex'))
    //nerdamer.setVar('p',0.7)
    divergence_f = data.bregdiv.buildFunction()
    //console.log(divergence_f,generator_val,divergence_f(5,generator_val))
    top_left= Math.max(divergence_f(data.bounds[0],generator_val),divergence_f(data.bounds[1],generator_val))
    bottom_right = minima_over_range(divergence_f,data.bounds,generator_val)
    bounds_diff = bounds[1]-bounds[0]
    y_diff = Math.abs(top_left - bottom_right)
    var divergenceboard = JXG.JSXGraph.initBoard('divergencebox', {boundingbox:[bounds[0]-0.3*bounds_diff,top_left+0.3*y_diff,bounds[1]+0.3*bounds_diff,bottom_right-0.3*y_diff], axis:true, showNavigation:false});
    divergenceboard.options.text.cssStyle = 'font-family: "Amazon Ember Mono"'
    fix_free = divergenceboard.create('slider',
    [[bounds[0],0.75*(top_left+0.3*y_diff)],
    [bounds[1],0.75*(top_left+0.3*y_diff)],[bounds[0],3*(bounds[0]+bounds[1])/4,bounds[1]]],
    {
      label: {fontSize: 18, strokeColor: 'black'},
              name: 'xyz',
               visible: true,
              suffixLabel: 'y = ',
    }
    );
    divergence = divergenceboard.create('functiongraph', [function(x){ return divergence_f(x,generator_val); },-10, 10],{strokeColor:'#000',strokeWidth:2, highlight: false});
    free_glider = divergenceboard.create('glider',[fix_free.Value(),divergence_f(fix_free.Value(),generator_val),divergence],{name:'y', highlight: false,strokeColor:'#013081',fillColor:'#013081',label:{autoPosition: true, offset:[-10, 10]}});
    free_glider.setAttribute({ fixed: true });
    divergence_fixed_point = divergenceboard.create('point', [fix_generator.Value(), 0],{ highlight: false,name:'x',label:{autoPosition: true, offset:[-10, 10],label:{autoPosition: true, offset:[10, 10]}}});
    free_eval = divergence_f(generator_val,free_glider.X())
    breg_dist_seg = divergenceboard.create('segment',[free_glider,[free_glider.X(),0]],{strokeColor:'#013081',strokeWidth:3, highlight: false,label:{autoPosition: true, offset:[10, 10]}});
    breg_dist_seg.setLabel('D(x||y)= '+Math.round(free_eval*100)/100)
    generator_fixed_y = generatorboard.create('point', [free_glider.X(), generator_f(free_glider.X())],{ highlight: false,name:'y',fixed:true,label:{autoPosition: true, offset:[-10, 10],label:{autoPosition: true, offset:[10, 10]}}});
           generator_breg_dist_seg = generatorboard.create('segment',[generator_fixed_y,[generator_fixed_y.X(),generator_fixed_y.Y()-divergence_f(generator_fixed_y.X(),generator_val)]],{strokeColor:'#013081',strokeWidth:3, highlight: false,label:{autoPosition: true, offset:[10, 10]}});
    // generator_breg_dist_seg.setLabel('D(x||y)= '+Math.round(free_eval*100)/100)
     fix_free.on('up', function(i){
       generator_val = fix_generator.Value()
       divergenceboard.removeObject(free_glider)
       free_glider = divergenceboard.create('glider',[fix_free.Value(),divergence_f(generator_val,fix_free.Value()),divergence],{name:'y', highlight: false,strokeColor:'#013081',fillColor:'#013081'});
       free_glider.setAttribute({ fixed: true });
       generatorboard.removeObject(generator_fixed_y)
       generatorboard.removeObject(generator_breg_dist_seg)
       generator_fixed_y = generatorboard.create('point', [free_glider.X(), generator_f(free_glider.X())],{ highlight: false,name:'y',fixed:true,label:{autoPosition: true, offset:[-10, 10],label:{autoPosition: true, offset:[10, 10]}}});
       free_eval = divergence_f(free_glider.X(),generator_val)
       generator_breg_dist_seg = generatorboard.create('segment',[generator_fixed_y,[generator_fixed_y.X(),generator_fixed_y.Y()-divergence_f(generator_fixed_y.X(),generator_val)]],{strokeColor:'#013081',strokeWidth:3, highlight: false,label:{autoPosition: true, offset:[10, 10]}});
       divergenceboard.removeObject(breg_dist_seg);
       breg_dist_seg = divergenceboard.create('segment',[free_glider,[free_glider.X(),0]],{strokeColor:'#013081',strokeWidth:3, highlight: false,label:{autoPosition: true, offset:[10, 10]}});
       breg_dist_seg.setLabel('D(x||y)= '+Math.round(free_eval*100)/100)
       divergenceboard.update()
     });
    divergenceboard.fullUpdate()
    panel4 = document.getElementById('panel4');
    panel4.style.display = 'block';
  }



  function isConvex(fn, bounds,variables) {
      //function that evaluates at midpoint and compares to assess if
      // function convex over bounds

        first_diff=[]
        variables.forEach(function(k){
          first_diff.push(nerdamer.diff(fn,k))
        })
        second_diff = []
        first_diff.forEach(function(f_dif){
          variables.forEach(function(k){
            second_diff.push(nerdamer.diff(f_dif,k))
          })
        })
        linspaces = []
        var j = 0
        for (var i=0;i<variables.length;i+=1){
          linspaces.push(linspace(bounds[j],bounds[j+1],stepsizes[i]))
          j=j+2
        }
        let f = (a, b) => [].concat(...a.map(a => b.map(b => [].concat(a, b))));
        let cartesian = (a, b, ...c) => b ? cartesian(f(a, b), ...c) : a;
        points_to_eval = cartesian(...linspaces)
        for (var i=0;i<points_to_eval.length;i+=1){
            hessian = [...Array(variables.length)].map(e => Array(variables.length))
            max = variables.length
            c=0
            second_diff.forEach(function(k){
              temp_f = k.buildFunction(variables)
              if (variables.length > 1){
                hessian[Math.floor(c/max)][c%max] = temp_f(...points_to_eval[i])
              } else{
                hessian[Math.floor(c/max)][c%max] = temp_f(points_to_eval[i])
              }

              c=c+1
            })

          hessian = math.matrix(hessian)
          eigenvalues = math.eigs(hessian).values
          //console.log(eigenvalues)
          for (var k=0;k<eigenvalues._size;k+=1){
            if(eigenvalues._data[k] <0 || math.im(eigenvalues._data[k])!=0){
              return false;

            };
          };
        };
        return true;
    }


function reset_panels() {
      counter=0
      panel2.style.display = "none";
      inputeq.style.display = "block";
      var errs = document.getElementsByClassName('bregplotserr')
      for (var i=0;i<errs.length;i+=1){
          errs[i].style.display = 'none';
          }
      bounds = document.getElementById('bounds_boxes')
      bounds.innerHTML = ''
      panel3.style.display='none';
      document.getElementById('convexity_test').innerHTML = ''
      panel4.style.display = 'none';
      //generatorboard.removeObject(generator_f)
      //generatorboard.update()
      //divergenceboard.removeObject(divergence_f)
      //generatorboard.update()

    }

    function onlyUnique(value, index, self) {
      return self.indexOf(value) === index;
    }
</script>
<br>
<br>
<h2 class="body-header">Common Loss Functions:</h2>
<section style='width:80%;margin:auto;'>
  <div class="accordion accordion-flush" id="commonlosslist">
  <div class="accordion-item">
    <h2 class="accordion-header" id="flush-headingOne">
      <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseOne" aria-expanded="false" aria-controls="flush-collapseOne">
        Squared Loss
      </button>
    </h2>
    <div id="flush-collapseOne" class="accordion-collapse collapse" aria-labelledby="flush-headingOne" data-bs-parent="#commonlosslist">
      <div class="accordion-body">Placeholder content for this accordion, which is intended to demonstrate the <code>.accordion-flush</code> class. This is the first item's accordion body.</div>
    </div>
  </div>
  <div class="accordion-item">
    <h2 class="accordion-header" id="flush-headingTwo">
      <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwo" aria-expanded="false" aria-controls="flush-collapseTwo">
        Kullbach Liebler Divergence
      </button>
    </h2>
    <div id="flush-collapseTwo" class="accordion-collapse collapse" aria-labelledby="flush-headingTwo" data-bs-parent="#commonlosslist">
      <div class="accordion-body">Placeholder content for this accordion, which is intended to demonstrate the <code>.accordion-flush</code> class. This is the second item's accordion body. Let's imagine this being filled with some actual content.</div>
    </div>
  </div>
  <div class="accordion-item">
    <h2 class="accordion-header" id="flush-headingThree">
      <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseThree" aria-expanded="false" aria-controls="flush-collapseThree">
        Bit Entropy
      </button>
    </h2>
    <div id="flush-collapseThree" class="accordion-collapse collapse" aria-labelledby="flush-headingFour" data-bs-parent="#commonlosslist">
      <div class="accordion-body">Placeholder content for this accordion, which is intended to demonstrate the <code>.accordion-flush</code> class. This is the third item's accordion body. Nothing more exciting happening here in terms of content, but just filling up the space to make it look, at least at first glance, a bit more representative of how this would look in a real-world application.</div>
    </div>
  </div>
  <div class="accordion-item">
    <h2 class="accordion-header" id="flush-headingFour">
      <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseFour" aria-expanded="false" aria-controls="flush-collapseThree">
        Burg Entropy
      </button>
    </h2>
    <div id="flush-collapseFour" class="accordion-collapse collapse" aria-labelledby="flush-headingFour" data-bs-parent="#commonlosslist">
      <div class="accordion-body">Placeholder content<code>import numpy</code> for this accordion, which is intended to demonstrate the <code>.accordion-flush</code> class. This is the third item's accordion body. Nothing more exciting happening here in terms of content, but just filling up the space to make it look, at least at first glance, a bit more representative of how this would look in a real-world application.</div>
    </div>
  </div>
</div>
  </section
<section>
  <br>
  <br>
  <h2  class="body-header">Applications of Bregman Divergences:</h2>
  <p style='padding-bottom:1%' class='body-text'>
    Bregman divergences are used to measure the dissimilarity between two probability distributions as such some examples of applications of Bregman divergences include:
<br>
<ol type='1' class='body-text'>
  <li style='padding-bottom:1%'>\( \textbf{Clustering}\): Bregman divergences can be used to define the dissimilarity between different clusters, which can then be used in algorithms such as k-means clustering.</li>
  <li style='padding-bottom:1%'>\( \textbf{Image compression}\): Bregman divergences can be used to measure the dissimilarity between an original image and a compressed version of the image, which can be used to optimize the compression algorithm.</li>
  <li style='padding-bottom:1%'>\( \textbf{Machine learning}\): Bregman divergences can be used as loss functions in machine learning algorithms, such as in the optimization of neural networks.</li>
  <li style='padding-bottom:1%'>\( \textbf{Recommender systems}\): Bregman divergences can be used to measure the dissimilarity between different users' preferences and can be used to make personalized recommendations.</li>
  <li style='padding-bottom:1%'>\( \textbf{Signal processing}\): Bregman divergences can be used in signal processing to measure the dissimilarity between a signal and a compressed version of the signal, which can be used to optimize the compression algorithm.</li>
</ol>

  </p>
<div style='width:45%;margin:auto; text-align: center'>
  <span  class="bold">Why would you use other dissimilarity measures?</span>
</div>


</body>
